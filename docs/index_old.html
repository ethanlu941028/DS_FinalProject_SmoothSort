<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smooth Sort 演算法視覺化</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            font-weight: 300;
            color: #4ec9b0;
        }
        #controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #252526;
            border-radius: 8px;
            border: 1px solid #333;
            flex-wrap: wrap;
        }
        #controls input[type="text"] {
            padding: 8px 12px;
            border: 1px solid #3c3c3c;
            background-color: #3c3c3c;
            color: #d4d4d4;
            border-radius: 4px;
            min-width: 250px;
            font-size: 16px;
        }
        #controls button {
            padding: 8px 20px;
            border: none;
            background-color: #0e639c;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        #controls button:hover {
            background-color: #1177bb;
        }
        #controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-container label {
            white-space: nowrap;
        }
        #speed-slider {
            cursor: pointer;
        }
        #canvas-container {
            width: 95%;
            max-width: 1200px;
            margin: 0 auto;
        }
        canvas {
            background-color: #252526;
            border: 1px solid #333;
            border-radius: 8px;
            width: 100%;
            height: auto;
        }
        #status-bar {
            margin-top: 15px;
            font-size: 14px;
            color: #9cdcfe;
            min-height: 20px;
        }
    </style>
</head>
<body>
    <h1>Smooth Sort 演算法視覺化</h1>
    <div id="controls">
        <input type="text" id="number-input" placeholder="輸入數字，用空格分隔 (例如: 7 2 8 1 4 9)">
        <button id="start-button">開始排序</button>
        <div class="slider-container">
            <label for="speed-slider">動畫速度:</label>
            <input type="range" id="speed-slider" min="20" max="1000" value="500">
            <span id="speed-value">500ms</span>
        </div>
    </div>
    <div id="status-bar">準備就緒</div>
    <div id="canvas-container">
        <canvas id="sort-canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('sort-canvas');
        const ctx = canvas.getContext('2d');
        const numberInput = document.getElementById('number-input');
        const startButton = document.getElementById('start-button');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        const statusBar = document.getElementById('status-bar');

        let animationSpeed = 500;
        let isSorting = false;
        let animationFrameId;

        // Leonardo numbers
        const LP = [1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049, 242785, 392835, 635621, 1028457, 1664079, 2692537, 4356617, 7049155, 11405773, 18454929, 29860703, 48315633, 78176337, 126491971, 204668309, 331160281, 535828591, 866988873];

        class Node {
            constructor(value, x = 0, y = 0) {
                this.value = value;
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.children = [];
                this.radius = 20;
                this.color = '#9cdcfe';
            }

            draw(context) {
                // Animate movement
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    this.x += dx * 0.1;
                    this.y += dy * 0.1;
                } else {
                    this.x = this.targetX;
                    this.y = this.targetY;
                }

                // Draw circle
                context.beginPath();
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                context.fillStyle = this.color;
                context.fill();
                context.strokeStyle = '#4ec9b0';
                context.stroke();

                // Draw value
                context.fillStyle = '#1e1e1e';
                context.font = '16px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(this.value, this.x, this.y);
            }

            drawEdges(context) {
                for (const child of this.children) {
                    context.beginPath();
                    context.moveTo(this.x, this.y);
                    context.lineTo(child.x, child.y);
                    context.strokeStyle = 'rgba(212, 212, 212, 0.5)';
                    context.stroke();
                    child.drawEdges(context);
                }
            }
        }

        class SmoothSorter {
            constructor(array) {
                this.nodes = array.map(val => new Node(val));
                this.heaps = []; // Forest of Leonardo heaps
                this.steps = []; // Queue of animation steps
                this.sortedArray = [];
            }

            generateSteps() {
                this.steps.push({ action: 'start', message: '開始建構堆森林...' });

                // --- Building Phase ---
                for (let i = 0; i < this.nodes.length; i++) {
                    const newNode = this.nodes[i];
                    this.steps.push({ action: 'add', nodeIndex: i, message: `讀取新節點: ${newNode.value}` });

                    // Merge Rule Check
                    if (this.heaps.length >= 2) {
                        const lastHeap = this.heaps[this.heaps.length - 1];
                        const secondLastHeap = this.heaps[this.heaps.length - 2];
                        
                        // Find Leonardo indices
                        const k = LP.indexOf(lastHeap.size);
                        const j = LP.indexOf(secondLastHeap.size);

                        if (j === k + 1) { // L(k+1) and L(k)
                            this.steps.push({ action: 'merge', message: `合併 L(${k+1}) 和 L(${k}) 成為 L(${k+2})` });
                            const mergedHeap = this.merge(secondLastHeap, lastHeap, newNode);
                            this.heaps.splice(this.heaps.length - 2, 2, mergedHeap);
                            this.siftDown(this.heaps.length - 1, true);
                        } else {
                            this.heaps.push(this.createHeap(newNode, 1)); // L(1)
                        }
                    } else {
                         this.heaps.push(this.createHeap(newNode, 1)); // L(1) or L(0)
                    }
                    this.rebalanceRoots();
                }
                
                this.steps.push({ action: 'build_done', message: '堆森林建構完成，開始排序階段...' });

                // --- Sorting Phase ---
                for (let i = this.nodes.length - 1; i >= 0; i--) {
                    this.steps.push({ action: 'sort_step', message: `處理最大的根節點` });
                    const largestHeap = this.heaps.pop();
                    this.sortedArray.unshift(largestHeap.root);

                    if (largestHeap.size > 1) {
                        const [left, right] = this.demerge(largestHeap);
                        this.heaps.push(left, right);
                        this.rebalanceRoots();
                    }
                }
                this.steps.push({ action: 'finish', message: '排序完成！' });
                return this.steps;
            }
            
            createHeap(rootNode, size) {
                return { root: rootNode, size: size };
            }

            merge(heap1, heap2, newNode) {
                newNode.children = [heap1.root, heap2.root];
                return this.createHeap(newNode, heap1.size + heap2.size + 1);
            }
            
            demerge(heap) {
                return [
                    this.createHeap(heap.root.children[0], LP[LP.indexOf(heap.size) - 2]),
                    this.createHeap(heap.root.children[1], LP[LP.indexOf(heap.size) - 1])
                ];
            }

            rebalanceRoots() {
                if (this.heaps.length < 2) return;

                for (let i = this.heaps.length - 2; i >= 0; i--) {
                    const rightHeap = this.heaps[i+1];
                    const leftHeap = this.heaps[i];

                    if (leftHeap.root.value > rightHeap.root.value) {
                        this.steps.push({ action: 'swap_roots', heapIndex1: i, heapIndex2: i + 1, message: `根節點失序 (${leftHeap.root.value} > ${rightHeap.root.value})，交換中...` });
                        // Swap roots
                        [leftHeap.root, rightHeap.root] = [rightHeap.root, leftHeap.root];
                        this.siftDown(i, false);
                    }
                }
            }

            siftDown(heapIndex, isMerge) {
                const heap = this.heaps[heapIndex];
                let current = heap.root;
                
                this.steps.push({ action: 'sift_start', heapIndex: heapIndex, message: `對根為 ${current.value} 的堆進行篩選` });

                while (heap.size > 1) {
                    let largestChild = null;
                    let largestChildIndex = -1;

                    if (current.children.length > 0) {
                        largestChild = current.children[0];
                        largestChildIndex = 0;
                    }
                    if (current.children.length > 1 && current.children[1].value > largestChild.value) {
                        largestChild = current.children[1];
                        largestChildIndex = 1;
                    }

                    if (largestChild && current.value < largestChild.value) {
                         this.steps.push({ action: 'sift_swap', parentNode: current, childNode: largestChild, message: `篩選: 交換 ${current.value} 和 ${largestChild.value}` });
                        [current.value, largestChild.value] = [largestChild.value, current.value];
                        
                        // This is a simplified model for visualization. A real sift would traverse down the tree structure.
                        // For this visualization, we just swap values. The tree structure is rebuilt on each frame.
                        // We need to find which sub-heap the largest child belongs to.
                        if (heap.size > 1) {
                            const k = LP.indexOf(heap.size);
                            if (k > 1) {
                                const leftSize = LP[k-2];
                                const rightSize = LP[k-1];
                                if (largestChildIndex === 0) { // Left child
                                     this.siftDownOnSubHeap(current.children[0], leftSize);
                                } else { // Right child
                                     this.siftDownOnSubHeap(current.children[1], rightSize);
                                }
                            }
                        }
                        // After swapping, we need to continue sifting down from the child's position
                        current = largestChild;
                    } else {
                        break; // Heap property is satisfied
                    }
                }
                 this.steps.push({ action: 'sift_end', heapIndex: heapIndex });
            }
            
            siftDownOnSubHeap(root, size) {
                 // A recursive helper for sifting down on sub-heaps, simplified for visualization
                let current = root;
                while(size > 1) {
                    let largestChild = null;
                    if (current.children.length > 0) largestChild = current.children[0];
                    if (current.children.length > 1 && current.children[1].value > largestChild.value) {
                        largestChild = current.children[1];
                    }

                    if (largestChild && current.value < largestChild.value) {
                        this.steps.push({ action: 'sift_swap', parentNode: current, childNode: largestChild, message: `(子篩選) 交換 ${current.value} 和 ${largestChild.value}` });
                        [current.value, largestChild.value] = [largestChild.value, current.value];
                        current = largestChild;
                        const k = LP.indexOf(size);
                        if (k > 1) {
                           size = (current === root.children[0]) ? LP[k-2] : LP[k-1];
                        } else {
                           break;
                        }
                    } else {
                        break;
                    }
                }
            }
        }

        let currentSorter;
        let stepQueue = [];
        let currentStep = 0;

        function setupCanvas() {
            const container = document.getElementById('canvas-container');
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = (window.innerHeight * 0.6) * dpr;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${window.innerHeight * 0.6}px`;
            ctx.scale(dpr, dpr);
        }

        function calculateLayout(heaps) {
            const totalWidth = canvas.width / (window.devicePixelRatio || 1);
            const yStep = 80;
            let currentX = 0;

            const heapWidths = heaps.map(heap => getTreeWidth(heap.root));
            const totalHeapWidth = heapWidths.reduce((sum, w) => sum + w, 0) + (heaps.length - 1) * 40;
            
            currentX = (totalWidth - totalHeapWidth) / 2;

            for (let i = 0; i < heaps.length; i++) {
                const heap = heaps[i];
                const treeWidth = heapWidths[i];
                positionNode(heap.root, currentX + treeWidth / 2, 50, treeWidth, yStep);
                currentX += treeWidth + 40; // Add spacing between heaps
            }
        }

        function getTreeWidth(node) {
            if (!node.children || node.children.length === 0) {
                return node.radius * 2 + 20; // Leaf node width
            }
            let width = 0;
            for (const child of node.children) {
                width += getTreeWidth(child);
            }
            return width;
        }

        function positionNode(node, x, y, availableWidth, yStep) {
            node.targetX = x;
            node.targetY = y;

            if (!node.children || node.children.length === 0) return;

            const childWidths = node.children.map(child => getTreeWidth(child));
            const totalChildWidth = childWidths.reduce((sum, w) => sum + w, 0);
            
            let currentX = x - totalChildWidth / 2;

            // Single child logic
            if (node.children.length === 1) {
                 positionNode(node.children[0], x - availableWidth / 4, y + yStep, availableWidth / 2, yStep);
            } else {
                for (let i = 0; i < node.children.length; i++) {
                    const child = node.children[i];
                    const childWidth = childWidths[i];
                    positionNode(child, currentX + childWidth / 2, y + yStep, childWidth, yStep);
                    currentX += childWidth;
                }
            }
        }

        function draw() {
            const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
            const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            if (currentSorter) {
                // Draw edges first
                currentSorter.heaps.forEach(heap => heap.root.drawEdges(ctx));
                // Draw nodes
                currentSorter.heaps.forEach(heap => drawNodeRecursive(heap.root));
                
                // Draw sorted part
                let sortedX = canvasWidth - 30;
                for(let i = currentSorter.sortedArray.length - 1; i >= 0; i--) {
                    const node = currentSorter.sortedArray[i];
                    node.targetX = sortedX;
                    node.targetY = canvasHeight - 40;
                    node.color = '#569cd6';
                    node.draw(ctx);
                    sortedX -= node.radius * 2.5;
                }
            }
        }
        
        function drawNodeRecursive(node) {
            node.draw(ctx);
            for(const child of node.children) {
                drawNodeRecursive(child);
            }
        }

        function animate() {
            draw();
            animationFrameId = requestAnimationFrame(animate);
        }

        async function executeSteps() {
            isSorting = true;
            startButton.disabled = true;

            for (currentStep = 0; currentStep < stepQueue.length; currentStep++) {
                const step = stepQueue[currentStep];
                statusBar.textContent = step.message || '';
                
                // Apply the logic of the step
                performStepAction(step);

                // Recalculate layout after action
                if (currentSorter) {
                    calculateLayout(currentSorter.heaps);
                }

                await new Promise(resolve => setTimeout(resolve, animationSpeed));
            }
            isSorting = false;
            startButton.disabled = false;
        }

        function performStepAction(step) {
            // This function is a bit of a cheat for visualization.
            // The Sorter class already built the final structures.
            // Here we just update the visual state based on the step description.
            // A more accurate (and complex) implementation would have the sorter
            // class modify the heaps step-by-step.
            
            if (step.action === 'swap_roots') {
                const heap1 = currentSorter.heaps[step.heapIndex1];
                const heap2 = currentSorter.heaps[step.heapIndex2];
                // The actual swap is already modeled in the sorter's logic.
                // We just highlight the nodes.
                heap1.root.color = '#d16969';
                heap2.root.color = '#d16969';
            } else if (step.action === 'sift_swap') {
                // The value swap is already done in the sorter's pre-calculation.
                // We just highlight.
                step.parentNode.color = '#dcdcaa';
                step.childNode.color = '#dcdcaa';
            } else {
                 // Reset colors
                 if(currentSorter) {
                    currentSorter.nodes.forEach(n => n.color = '#9cdcfe');
                 }
            }
        }

        function startSort() {
            if (isSorting) return;

            const inputText = numberInput.value.trim();
            if (!inputText) {
                alert('請輸入數字！');
                return;
            }
            const numbers = inputText.split(/\s+/).map(Number).filter(n => !isNaN(n));
            if (numbers.length === 0) {
                alert('請輸入有效的數字！');
                return;
            }

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // The sorter pre-calculates all steps and the final heap structures
            currentSorter = new SmoothSorter(numbers);
            stepQueue = currentSorter.generateSteps();
            
            // For visualization, we need to reset the sorter to its initial state
            // and apply steps one by one.
            currentSorter = new SmoothSorter(numbers); // Re-initialize
            currentSorter.heaps = [];
            currentSorter.sortedArray = [];


            setupCanvas();
            animate();
            
            // A more refined step executor for visualization
            executeVisualizationSteps();
        }
        
        async function executeVisualizationSteps() {
            isSorting = true;
            startButton.disabled = true;
            
            const initialNodes = currentSorter.nodes.slice();
            let heapForest = [];
            let sortedVis = [];

            for(const step of stepQueue) {
                statusBar.textContent = step.message;
                
                // Reset colors
                initialNodes.forEach(n => n.color = '#9cdcfe');
                
                if (step.action === 'add') {
                    const newNode = initialNodes[step.nodeIndex];
                    
                    if (heapForest.length >= 2) {
                        const last = heapForest[heapForest.length - 1];
                        const secondLast = heapForest[heapForest.length - 2];
                        const k = LP.indexOf(last.size);
                        const j = LP.indexOf(secondLast.size);

                        if (j === k + 1) {
                            // Merge
                            heapForest.pop();
                            heapForest.pop();
                            newNode.children = [secondLast.root, last.root];
                            heapForest.push({root: newNode, size: secondLast.size + last.size + 1});
                        } else {
                            heapForest.push({root: newNode, size: 1});
                        }
                    } else {
                        heapForest.push({root: newNode, size: 1});
                    }
                }
                
                if (step.action === 'swap_roots') {
                    const h1 = heapForest[step.heapIndex1];
                    const h2 = heapForest[step.heapIndex2];
                    [h1.root, h2.root] = [h2.root, h1.root];
                    h1.root.color = '#d16969';
                    h2.root.color = '#d16969';
                }

                if (step.action === 'sift_swap') {
                    [step.parentNode.value, step.childNode.value] = [step.childNode.value, step.parentNode.value];
                    step.parentNode.color = '#dcdcaa';
                    step.childNode.color = '#dcdcaa';
                }
                
                if (step.action === 'sort_step') {
                    if(heapForest.length > 0) {
                        const largestHeap = heapForest.pop();
                        sortedVis.unshift(largestHeap.root);
                        
                        if(largestHeap.size > 1) {
                            const k = LP.indexOf(largestHeap.size);
                            const leftChild = largestHeap.root.children[0];
                            const rightChild = largestHeap.root.children[1];
                            
                            // Clear children to break tree structure
                            largestHeap.root.children = [];

                            const leftHeap = { root: leftChild, size: LP[k-2] };
                            const rightHeap = { root: rightChild, size: LP[k-1] };
                            heapForest.push(leftHeap, rightHeap);
                        }
                    }
                }

                // Update the global sorter object for drawing
                currentSorter.heaps = heapForest;
                currentSorter.sortedArray = sortedVis;
                calculateLayout(currentSorter.heaps);

                await new Promise(resolve => setTimeout(resolve, animationSpeed));
            }

            statusBar.textContent = '排序完成！';
            isSorting = false;
            startButton.disabled = false;
        }


        // Event Listeners
        startButton.addEventListener('click', startSort);
        speedSlider.addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value, 10);
            speedValue.textContent = `${animationSpeed}ms`;
        });
        window.addEventListener('resize', () => {
            if (!isSorting) {
                setupCanvas();
                draw();
            }
        });

        // Initial setup
        numberInput.value = "7 2 8 1 4 9";
        setupCanvas();
        draw();

    </script>
</body>
</html>

</body>
</html>
