<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Smooth Sort Visualizer</title>
  <style>
    :root{
      --bg:#0f1724; --panel:#0b1220; --bar:#3b82f6; --compare:#ef4444; --move:#f59e0b; --done:#10b981; --text:#e6eef8;
      --max-height:360px; --gap:6px;
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:Inter,ui-sans-serif,system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(180deg,#071024 0%, #041021 100%); color:var(--text);}
    .wrap{max-width:980px;margin:28px auto;padding:20px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
    h1{margin:0 0 12px 0;font-size:20px}
    .controls{display:flex;gap:10px;align-items:center;margin-bottom:14px}
    input[type=text]{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:var(--text)}
    button{padding:10px 14px;border-radius:8px;border:none;cursor:pointer;background:#1f2937;color:var(--text)}
    button:disabled{opacity:0.4;cursor:not-allowed}
    .info{font-size:13px;color:#9fb0d7;margin-left:6px}

    .visual-wrap{margin-top:18px;padding:14px;background:rgba(255,255,255,0.02);border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
    .bars{display:flex;align-items:flex-end;gap:var(--gap);height:var(--max-height);padding:12px}

    .bar{flex:1 1 auto;min-width:14px;display:flex;align-items:flex-end;justify-content:center;position:relative;transition:height 200ms ease, background 120ms ease, transform 200ms ease; border-radius:4px 4px 0 0}
    .bar .label{position:absolute;bottom:4px;font-size:12px;color:#021022;transform:translateY(100%)}
    .bar.compare{background:var(--compare);transform:translateY(-3px)}
    .bar.move{background:var(--move);transform:translateY(-6px)}
    .bar.done{background:var(--done);transform:none}

    .small{font-size:13px;color:#9fb0d7;margin-top:8px}
    .footer{margin-top:12px;font-size:13px;color:#7ea0d6}

    @media (max-width:600px){ .bars{gap:4px} }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üîß Smooth Sort Visualizer (Dijkstra)</h1>
    <div class="controls">
      <input id="inputNumbers" type="text" placeholder="Ëº∏ÂÖ•Êï∏Â≠óÔºå‰ª•Á©∫Ê†ºÂàÜÈöîÔºà‰æãÂ¶ÇÔºö7 2 8 1 4 9Ôºâ" />
      <button id="btnStart">Start Sorting</button>
      <button id="btnReset">Reset</button>
      <div class="info">Âª∂ÈÅ≤: <span id="delayLabel">500</span>ms</div>
      <input id="delayRange" type="range" min="20" max="1200" value="500" style="width:220px;margin-left:8px"/>
    </div>

    <div class="visual-wrap">
      <div id="bars" class="bars"></div>
      <div class="small">ÊØîËºÉÊôÇÁÇ∫ <span style="color:var(--compare)">Á¥ÖËâ≤</span>Ôºå‰∫§Êèõ/ÁßªÂãïÁÇ∫ <span style="color:var(--move)">ÈªÉËâ≤</span>ÔºåÂÆåÊàêÁÇ∫ <span style="color:var(--done)">Á∂†Ëâ≤</span></div>
    </div>

    <div class="visual-wrap" style="margin-top:12px;">
      <canvas id="treeCanvas" width="900" height="520" style="width:100%;height:520px;background:rgba(255,255,255,0.01);border-radius:8px;border:1px solid rgba(255,255,255,0.02)"></canvas>
      <div class="small">Ê®πÂΩ¢ÁµêÊßãÔºàLeonardo heapsÔºâË¶ñË¶∫Âåñ ‚Äî ÁØÄÈªû‰ª£Ë°®Èô£Âàó‰∏äÁöÑÂÖÉÁ¥†ÔºåÁ∑ö‰ª£Ë°®Áà∂/Â≠êÈóú‰øÇ„ÄÇ</div>
    </div>

    <div class="footer">Ë™™ÊòéÔºöÊ≠§Ë¶ñË¶∫Âåñ‰ΩøÁî® Leonardo numbers Âª∫Á´ã‰∏ÄÂÄã Leonardo-heap forestÔºåÂÜçÈÄ≤Ë°å trinkle Ëàá sift Êìç‰Ωú‰ª•ÊéíÂ∫è„ÄÇÂèØË™øÊï¥Âª∂ÈÅ≤ËßÄÂØüÁ¥∞ÁØÄ„ÄÇ</div>
  </div>

  <script>
    // Utility
    const $ = (s) => document.querySelector(s);
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    const input = $('#inputNumbers');
    const btnStart = $('#btnStart');
    const btnReset = $('#btnReset');
    const barsEl = $('#bars');
    const delayRange = $('#delayRange');
    const delayLabel = $('#delayLabel');

    let arr = [];
    let original = [];
    let visualValues = [];
    let delay = parseInt(delayRange.value,10);

    delayRange.addEventListener('input', ()=>{ delay = parseInt(delayRange.value,10); delayLabel.textContent = delay; });

    function renderBars() {
      barsEl.innerHTML = '';
      if (!arr.length) return;
      const values = (visualValues && visualValues.length === arr.length) ? visualValues : arr;
      const max = Math.max(...values.map(v=>Math.abs(v)),1);
      const maxH = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-height')) || 360;
      const scale = (maxH - 28) / max;
      values.forEach((val,i)=>{
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.dataset.index = i;
        bar.style.height = Math.max(8, Math.abs(val) * scale) + 'px';
        bar.style.background = 'var(--bar)';
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = String(val);
        bar.appendChild(label);
        barsEl.appendChild(bar);
      });
      // after bars updated, also redraw tree
      drawTreeStructure();
    }

    function setBarClass(i, cls, add=true) {
      const b = barsEl.querySelector(`.bar[data-index='${i}']`);
      if (!b) return;
      if (add) b.classList.add(cls); else b.classList.remove(cls);
    }

    async function highlightCompare(i,j) {
      setBarClass(i,'compare',true); setBarClass(j,'compare',true);
      await sleep(delay);
      setBarClass(i,'compare',false); setBarClass(j,'compare',false);
    }

    async function animateAssign(target, source) {
      // show movement: source -> target
      const moveVal = (visualValues && visualValues.length === arr.length) ? visualValues[source] : arr[source];
      setBarClass(source,'move',true); setBarClass(target,'move',true);
      await sleep(delay/1.2);
      // Update underlying data but keep old visual values during animation
      arr[target] = moveVal;
      await sleep(delay/1.2);
      // ATOMIC UPDATE: Now update visual values and redraw everything at once
      if (!visualValues || visualValues.length !== arr.length) visualValues = arr.slice();
      visualValues[target] = moveVal;
      setBarClass(source,'move',false); setBarClass(target,'move',false);
      renderBars();
    }

    async function placeValue(idx, value) {
      setBarClass(idx,'move',true);
      await sleep(delay/2);
      arr[idx] = value;
      await sleep(delay/2);
      // ATOMIC UPDATE: Update visual value and redraw at the end
      if (!visualValues || visualValues.length !== arr.length) visualValues = arr.slice();
      visualValues[idx] = value;
      setBarClass(idx,'move',false);
      renderBars();
    }

    function markAllDone() {
      const bs = barsEl.querySelectorAll('.bar');
      bs.forEach(b=>{ b.classList.remove('compare'); b.classList.remove('move'); b.classList.add('done'); });
      renderBars();
    }

    // ---------- Tree Visualization (Canvas) ----------
    const treeCanvas = document.getElementById('treeCanvas');
    const treeCtx = treeCanvas.getContext('2d');

    // animation state for smooth node movement
    const LERP = 0.12; // interpolation factor (0-1), increase to speed up
    const LEVEL_HEIGHT = 80; // fixed comfortable vertical spacing between levels
    const SIDE_PADDING = 50; // horizontal padding to prevent node clipping at edges
    let targetPositions = []; // {x,y} per index in logical coordinates
    let visualPositions = []; // {x,y} per index for smooth animation
    let parentGlobal = []; // immediate parent mapping returned from getForest (latest)
    let persistentParent = []; // persistent parent mapping used for drawing until finish
    let currentScale = 1; // scale factor applied to fit tall trees
    let currentTopMargin = 0; // canvas pixel top margin for centering after scaling
    let currentOffsetX = 0; // canvas pixel left offset used when centering scaled content
    let animationStarted = false;
    let isAlgorithmFinished = false; // when true, begin fade-to-linear
    let finishProgress = 0; // 0..1 progress of finish animation
    const FINISH_SPEED = 0.03; // per frame advancement of finish animation

    function resizeTreeCanvas(){
      const rect = treeCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      treeCanvas.width = rect.width * dpr;
      treeCanvas.height = rect.height * dpr;
      treeCtx.setTransform(dpr,0,0,dpr,0,0);
      // update targets; animation loop will draw
      drawTreeStructure();
      if (!animationStarted) { animationStarted = true; requestAnimationFrame(animationLoop); }
    }
    window.addEventListener('resize', resizeTreeCanvas);
    resizeTreeCanvas();

    function buildHeapLinks(root, order, parent){
      if (order <= 1) return;
      const rt = root - 1;
      const lf = root - 1 - LP[order - 2];
      if (lf >=0 && lf < arr.length) parent[lf] = root;
      if (rt >=0 && rt < arr.length) parent[rt] = root;
      buildHeapLinks(lf, order - 2, parent);
      buildHeapLinks(rt, order - 1, parent);
    }

    function getForest(head, p, pshift){
      const parent = new Array(arr.length).fill(null);
      let pTemp = p >>> 0;
      let pshiftTemp = pshift;
      let idx = head - 1;
      while (pTemp !== 0 && idx >= 0){
        if ((pTemp & 1) === 1){
          // heap with root at idx of order pshiftTemp
          if (idx >=0 && pshiftTemp >= 0) {
            parent[idx] = null; // root has no parent
            buildHeapLinks(idx, pshiftTemp, parent);
            idx -= LP[pshiftTemp];
            pTemp >>= 1;
            pshiftTemp -= 1;
          } else break;
        } else {
          idx -=1;
          pTemp >>=1;
          pshiftTemp +=1;
        }
      }
      return parent;
    }

    // compute target positions (no immediate drawing) and store parent map
    // compute target positions (no immediate drawing) and store/update persistent parent map
    function drawTreeStructure(){
      if (!arr.length) {
        // clear targets and canvas
        targetPositions = [];
        parentGlobal = [];
        persistentParent = [];
        treeCtx.clearRect(0,0,treeCanvas.width, treeCanvas.height);
        return;
      }

      const parent = getForest(globalState.head, globalState.p, globalState.pshift);
      parentGlobal = parent;

      const rect = treeCanvas.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      const padX = 24;
      const padY = 20;
      const usableW = width - padX*2;
      const n = arr.length;

      // update persistentParent: only overwrite if parent info exists; keep previous until finish
      if (!persistentParent || persistentParent.length !== n) persistentParent = new Array(n).fill(null);
      for (let i=0;i<n;i++){
        if (parent[i] != null) persistentParent[i] = parent[i];
        else if (isAlgorithmFinished) persistentParent[i] = null; // when finished, we will transition to linear
      }

      // compute depth by following persistent parent chain
      const depth = new Array(n).fill(0);
      let maxDepth = 0;
      for (let i=0;i<n;i++){
        let d = 0;
        let cur = i;
        while (persistentParent[cur] != null){
          d++;
          cur = persistentParent[cur];
          if (d>200) break;
        }
        depth[i]=d;
        if (d>maxDepth) maxDepth=d;
      }
      // use a fixed comfortable vertical spacing per level
      let levelH = LEVEL_HEIGHT;

      // ---------- new layout: recursive subtree centering ----------
      // build children lists from persistentParent
      const children = new Array(n).fill(0).map(()=>[]);
      for (let i=0;i<n;i++){
        const pidx = persistentParent[i];
        if (pidx != null && pidx >= 0 && pidx < n) children[pidx].push(i);
      }

      // find roots (nodes that are not children of any node)
      const isChild = new Array(n).fill(false);
      for (let i=0;i<n;i++){ for (const c of children[i]) isChild[c] = true; }
      const roots = [];
      for (let i=0;i<n;i++){ if (!isChild[i]) roots.push(i); }

      // count leaves per subtree
      const leafCount = new Array(n).fill(-1);
      function countLeaves(u){
        if (leafCount[u] !== -1) return leafCount[u];
        if (!children[u] || children[u].length === 0) return leafCount[u] = 1;
        let s = 0; for (const c of children[u]) s += countLeaves(c); return leafCount[u] = s;
      }
      let totalLeaves = 0;
      for (const r of roots) totalLeaves += countLeaves(r);
      if (totalLeaves === 0) totalLeaves = n; // fallback

      const leafSpacing = usableW / totalLeaves;
      let nextLeaf = 0;
      const xPositions = new Array(n).fill(null);

      function assignX(u){
        const ch = children[u];
        if (!ch || ch.length === 0){
          const x = padX + (nextLeaf + 0.5) * leafSpacing;
          xPositions[u] = x;
          nextLeaf++;
        } else {
          for (const c of ch) assignX(c);
          if (ch.length === 1) {
            // LEFT-bias single child: parent sits to the right of its single child
            const c = ch[0];
            xPositions[u] = xPositions[c] + (leafSpacing / 2);
          } else {
            let sum = 0; for (const c of ch) sum += xPositions[c];
            xPositions[u] = sum / ch.length;
          }
        }
      }

      // process roots left-to-right
      for (const r of roots){ assignX(r); }

      // fallback: nodes that somehow weren't assigned
      for (let i=0;i<n;i++){ if (xPositions[i] == null) xPositions[i] = padX + (i/(Math.max(1,n-1))) * usableW; }

      // Normalize X positions so the leftmost will become padX in normalized coords
      let minX = Infinity, maxX = -Infinity;
      for (let i=0;i<n;i++){ if (xPositions[i] < minX) minX = xPositions[i]; if (xPositions[i] > maxX) maxX = xPositions[i]; }
      if (!isFinite(minX)) { minX = padX; maxX = padX + usableW; }
      // Calculate node radius BEFORE computing contentWidth so we can account for node size
      const nodeRadius = Math.min(20, Math.max(10, ((width) - 48) / Math.max(8,n)));
      // Add node radius AND side padding to prevent clipping at edges
      const contentWidth = (maxX - minX) + (nodeRadius * 2) + SIDE_PADDING;

      // compute required height for the tree using fixed level height
      const requiredHeight = padY*2 + (maxDepth) * levelH + 40; // extra padding

      // compute final scale that fits both width and height
      const scaleX = rect.width / contentWidth;
      const scaleY = rect.height / requiredHeight;
      const finalScale = Math.min(1, scaleX, scaleY);
      currentScale = finalScale;

      // compute offsets to center the content in canvas pixels
      const offsetX = (rect.width - contentWidth * finalScale) / 2;
      const offsetY = (rect.height - requiredHeight * finalScale) / 2;
      currentOffsetX = offsetX; currentTopMargin = offsetY;

      // create target positions for every node (normalized X coords)
      targetPositions = new Array(n);
      for (let i=0;i<n;i++){
        if (!isAlgorithmFinished){
          // Shift X by nodeRadius + SIDE_PADDING/2 to ensure nodes don't clip at edges
          const x = (xPositions[i] - minX) + nodeRadius + (SIDE_PADDING / 2);
          const y = padY + depth[i]*levelH;
          targetPositions[i] = { x: x, y: y+12 };
        } else {
          // finished: linear center line (normalized to logical coords considering offsets/scale)
          // Use nodeRadius + SIDE_PADDING/2 for consistent spacing with tree layout
          const linearWidth = usableW - nodeRadius * 2;
          const x = nodeRadius + (SIDE_PADDING / 2) + (i/(Math.max(1,n-1))) * linearWidth;
          const y = (rect.height / 2 - currentTopMargin) / Math.max(1,currentScale);
          targetPositions[i] = { x: x, y: y };
        }
      }

      // initialize visual positions to target (if empty)
      for (let i=0;i<targetPositions.length;i++){
        if (!visualPositions[i]) visualPositions[i] = { x: targetPositions[i].x, y: targetPositions[i].y };
      }
    }

    // animation loop: lerp visualPositions -> targetPositions and draw persistent edges/nodes
    function animationLoop(){
      // ensure we have targets
      drawTreeStructure();

      const rect = treeCanvas.getBoundingClientRect();
      treeCtx.clearRect(0,0,rect.width,rect.height);

      const n = arr.length;

      // handle finish progression if algorithm finished
      if (isAlgorithmFinished && finishProgress < 1){
        finishProgress = Math.min(1, finishProgress + FINISH_SPEED);
        if (finishProgress === 1){
          // fully finished: clear persistent parents so edges stop being drawn in subsequent frames
          persistentParent = new Array(n).fill(null);
        }
      }

      // update visuals towards targets
      for (let i=0;i<n;i++){
        const t = targetPositions[i] || { x: (i/(Math.max(1,n-1)))*rect.width, y: rect.height - 20 };
        if (!visualPositions[i]) visualPositions[i] = { x: t.x, y: t.y };
        visualPositions[i].x += (t.x - visualPositions[i].x) * LERP;
        visualPositions[i].y += (t.y - visualPositions[i].y) * LERP;
      }

      // draw edges for all persistent parent links (persistent)
      treeCtx.lineWidth = 2;
      const edgeColor = getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#e6eef8';
      // use alpha fading when finishing
      const edgeAlpha = isAlgorithmFinished ? (1 - finishProgress) : 1;

      // apply scaling/translation to keep tree within canvas
      treeCtx.save();
      // scale first so we can translate in logical units properly
      treeCtx.scale(currentScale, currentScale);
      // translate in pre-scale logical units so the post-scale content is centered
      treeCtx.translate(currentOffsetX / Math.max(1,currentScale), currentTopMargin / Math.max(1,currentScale));

      if (edgeAlpha > 0){
        treeCtx.save();
        treeCtx.globalAlpha = edgeAlpha;
        treeCtx.strokeStyle = edgeColor;
        for (let i=0;i<n;i++){
          const p = persistentParent[i];
          if (p != null && visualPositions[i] && visualPositions[p]){
            const x1 = visualPositions[p].x;
            const y1 = visualPositions[p].y;
            const x2 = visualPositions[i].x;
            const y2 = visualPositions[i].y;
            treeCtx.beginPath();
            treeCtx.moveTo(x1,y1);
            treeCtx.lineTo(x2,y2);
            treeCtx.stroke();
          }
        }
        treeCtx.restore();
      }

      // draw nodes using visual positions
      const nodeRadius = Math.min(20, Math.max(10, ((rect.width) - 48) / Math.max(8,n)));
      for (let i=0;i<n;i++){
        const vp = visualPositions[i];
        if (!vp) continue;
        // pick color based on bar state
        const b = barsEl.querySelector(`.bar[data-index='${i}']`);
        let fill = getComputedStyle(document.documentElement).getPropertyValue('--bar').trim();
        if (b){
          if (b.classList.contains('compare')) fill = getComputedStyle(document.documentElement).getPropertyValue('--compare').trim();
          else if (b.classList.contains('move')) fill = getComputedStyle(document.documentElement).getPropertyValue('--move').trim();
          else if (b.classList.contains('done')) fill = getComputedStyle(document.documentElement).getPropertyValue('--done').trim();
        }

        treeCtx.beginPath();
        treeCtx.fillStyle = fill;
        treeCtx.strokeStyle = '#021022';
        treeCtx.lineWidth = 1;
        treeCtx.arc(vp.x, vp.y, nodeRadius, 0, Math.PI*2);
        treeCtx.fill();
        treeCtx.stroke();

        treeCtx.fillStyle = '#021022';
        treeCtx.font = `${Math.max(10, nodeRadius-6)}px sans-serif`;
        treeCtx.textAlign = 'center';
        treeCtx.textBaseline = 'middle';
        const displayVal = (visualValues && visualValues.length === arr.length) ? visualValues[i] : arr[i];
        treeCtx.fillText(String(displayVal), vp.x, vp.y);
      }

      // restore transform after drawing
      treeCtx.restore();

      requestAnimationFrame(animationLoop);
    }

    // globalState to hold current head/p/pshift for visualization
    const globalState = { head: 0, p: 1 >>> 0, pshift: 1 };

    // ---------- Smoothsort Implementation (port of Java/Wikibooks) ----------
    const LP = [1,1,3,5,9,15,25,41,67,109,177,287,465,753,1219,1973,3193,5167,8361,13529,21891,35421,57313,92735,150049,242785,392835,635621,1028457,1664079,2692537,4356617,7049155,11405773,18454929,29860703,48315633,78176337,126491971,204668309,331160281,535828591,866988873];

    function ctz(x){
      // count trailing zeros of 32-bit unsigned
      if (x === 0) return 32;
      let c = 0;
      while ((x & 1) === 0) { x >>>= 1; c++; }
      return c;
    }

    async function sift(m, pshift, head) {
      let val = m[head];
      while (pshift > 1) {
        const rt = head - 1;
        const lf = head - 1 - LP[pshift - 2];

        // compare val with children
        // We animate comparisons with values at lf and rt
        await highlightCompare(head, lf);
        await highlightCompare(head, rt);

        if (val >= m[lf] && val >= m[rt]) break;
        if (m[lf] >= m[rt]) {
          // m[head] = m[lf]; head = lf; pshift -=1;
          await animateAssign(head, lf);
          head = lf;
          pshift -= 1;
        } else {
          await animateAssign(head, rt);
          head = rt;
          pshift -= 2;
        }
        // update global state so tree visualization stays in sync
        globalState.head = head;
        globalState.pshift = pshift;
        drawTreeStructure();
      }
      // place val into head
      await placeValue(head, val);
      globalState.head = head;
      globalState.pshift = pshift;
      drawTreeStructure();
    }

    async function trinkle(m, p, pshift, head, trusty) {
      let val = m[head];
      while (p !== 1) {
        const stepson = head - LP[pshift];
        // compare stepson with val
        await highlightCompare(head, stepson);
        if (m[stepson] <= val) break;

        if (!trusty && pshift > 1) {
          const rt = head - 1;
          const lf = head - 1 - LP[pshift - 2];
          // if either child >= stepson then break
          await highlightCompare(rt, stepson);
          await highlightCompare(lf, stepson);
          if (m[rt] >= m[stepson] || m[lf] >= m[stepson]) break;
        }

        // move stepson up
        await animateAssign(head, stepson);
        head = stepson;
        // update global state to reflect head change
        globalState.head = head;
        drawTreeStructure();

        const trail = ctz(p & ~1 >>> 0);
        p >>>= trail;
        pshift += trail;
        // update global state to reflect p/pshift change
        globalState.p = p;
        globalState.pshift = pshift;
        drawTreeStructure();
        trusty = false;
      }
      if (!trusty) {
        await placeValue(head, val);
        await sift(m, pshift, head);
      }
    }

    async function smoothSortAnimated(m) {
      const n = m.length;
      if (n < 2) return;

      let head = 0;
      let p = 1 >>> 0;
      let pshift = 1;

      // initial global state
      globalState.head = head; globalState.p = p; globalState.pshift = pshift; drawTreeStructure();

      while (head < n) {
        // keep global state updated for visualization
        globalState.head = head; globalState.p = p; globalState.pshift = pshift; drawTreeStructure();

        if ((p & 3) === 3) {
          await sift(m, pshift, head);
          p >>>= 2;
          pshift += 2;
        } else {
          if (LP[pshift - 1] >= n - head) {
            await trinkle(m, p, pshift, head, false);
          } else {
            await sift(m, pshift, head);
          }

          if (pshift === 1) { p <<= 1; pshift = 0; }
          else { p <<= (pshift - 1); pshift = 1; }
        }
        p |= 1;
        head++;

        // update global state after changes
        globalState.head = head; globalState.p = p; globalState.pshift = pshift; drawTreeStructure();
      }

      await trinkle(m, p, pshift, head - 1, false);

      while (pshift !== 1 || p !== 1) {
        if (pshift <= 1) {
          const trail = ctz(p & ~1 >>> 0);
          p >>>= trail;
          pshift += trail;
        } else {
          p <<= 2;
          p ^= 7;
          pshift -= 2;

          await trinkle(m, p >>> 1, pshift + 1, head - LP[pshift] - 1, true);
          await trinkle(m, p, pshift, head - 1, true);
        }
        head--;
        globalState.head = head; globalState.p = p; globalState.pshift = pshift; drawTreeStructure();
      }
    }

    // ---------- UI / Wiring ----------
    btnStart.addEventListener('click', async ()=>{
      const raw = input.value.trim();
      if (!raw) return alert('Ë´ãËº∏ÂÖ•Êï∏Â≠ó');
      const parts = raw.split(/\s+/).map(x=>Number(x)).filter(x=>!Number.isNaN(x));
      if (!parts.length) return alert('Êâæ‰∏çÂà∞ÊúâÊïàÊï∏Â≠ó');
      arr = parts.slice(); original = parts.slice(); visualValues = arr.slice();
      // reset visualization global state
      globalState.head = 0; globalState.p = 1 >>> 0; globalState.pshift = 1; drawTreeStructure();
      // reset persistent/final flags
      isAlgorithmFinished = false; finishProgress = 0; persistentParent = [];
      renderBars();
      // disable UI
      btnStart.disabled = true; input.disabled = true; delayRange.disabled = true; btnReset.disabled = true;

      try {
        await smoothSortAnimated(arr);
        // mark final
        markAllDone();
        // begin finish animation: fade edges and move nodes to linear
        isAlgorithmFinished = true; finishProgress = 0;
      } catch (err) {
        console.error(err);
        alert('ÊéíÂ∫èÈÅéÁ®ãÁôºÁîüÈåØË™§ÔºåË´ãÁúã console Ë®äÊÅØ„ÄÇ');
      }

      btnStart.disabled = false; input.disabled = false; delayRange.disabled = false; btnReset.disabled = false;
    });

    btnReset.addEventListener('click', ()=>{
      arr = original.slice(); visualValues = arr.slice();
      globalState.head = 0; globalState.p = 1 >>> 0; globalState.pshift = 1;
      // reset persistent/final flags and visual positions for fresh start
      isAlgorithmFinished = false; finishProgress = 0; persistentParent = []; targetPositions = []; visualPositions = [];
      renderBars();
    });

    // allow pressing Enter to start
    input.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') btnStart.click(); });

    // initial demo
    input.value = '3 1 4 5 2 10 9 8 7';
    arr = input.value.split(/\s+/).map(x=>Number(x)); visualValues = arr.slice();
    globalState.head = 0; globalState.p = 1 >>> 0; globalState.pshift = 1; isAlgorithmFinished = false; finishProgress = 0; persistentParent = [];
    renderBars();

  </script>
</body>
</html>