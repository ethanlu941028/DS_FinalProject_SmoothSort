<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smooth Sort æ¼”ç®—æ³•è¦–è¦ºåŒ– - Leonardo å †æ£®æ—</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            color: #d4d4d4;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            font-weight: 300;
            color: #4ec9b0;
            margin-bottom: 10px;
            text-align: center;
        }
        .subtitle {
            color: #858585;
            font-size: 13px;
            margin-bottom: 20px;
            text-align: center;
        }
        #controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px 20px;
            background-color: #252526;
            border-radius: 8px;
            border: 1px solid #3c3c3c;
            flex-wrap: wrap;
            width: 100%;
            max-width: 1400px;
        }
        #controls input[type="text"] {
            padding: 10px 12px;
            border: 1px solid #3c3c3c;
            background-color: #3c3c3c;
            color: #d4d4d4;
            border-radius: 4px;
            min-width: 250px;
            font-size: 14px;
        }
        #controls button {
            padding: 10px 20px;
            border: none;
            background-color: #0e639c;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        #controls button:hover:not(:disabled) {
            background-color: #1177bb;
        }
        #controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }
        .slider-container label {
            white-space: nowrap;
            font-size: 13px;
        }
        #speed-slider {
            cursor: pointer;
            width: 120px;
        }
        #speed-value {
            font-size: 13px;
            min-width: 45px;
        }
        .main-container {
            width: 100%;
            max-width: 1400px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #canvas-section {
            flex: 1;
            min-width: 500px;
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 8px;
            padding: 15px;
        }
        canvas {
            background-color: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            width: 100%;
            height: auto;
            display: block;
        }
        #info-panel {
            width: 320px;
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 700px;
            overflow-y: auto;
        }
        .panel-section {
            border-bottom: 1px solid #3c3c3c;
            padding-bottom: 12px;
        }
        .panel-section:last-child {
            border-bottom: none;
        }
        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: #4ec9b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        .state-description {
            font-size: 13px;
            line-height: 1.5;
            color: #d4d4d4;
        }
        .heap-info {
            font-size: 12px;
            font-family: 'Courier New', monospace;
            background-color: #1e1e1e;
            padding: 8px;
            border-radius: 4px;
            margin: 4px 0;
            color: #9cdcfe;
        }
        .legend {
            font-size: 11px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #4ec9b0;
        }
        .legend-item.blue .legend-color {
            background-color: #569cd6;
        }
        .legend-item.gold .legend-color {
            background-color: #dcdcaa;
        }
        .legend-item.red .legend-color {
            background-color: #d16969;
        }
        .legend-item.green .legend-color {
            background-color: #6a9955;
        }
        .button-group {
            display: flex;
            gap: 10px;
        }
        #prev-step, #next-step {
            flex: 1;
            padding: 8px 12px;
            border: none;
            background-color: #0e639c;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        #prev-step:hover:not(:disabled), #next-step:hover:not(:disabled) {
            background-color: #1177bb;
        }
        #prev-step:disabled, #next-step:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .step-counter {
            text-align: center;
            font-size: 12px;
            color: #9cdcfe;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <h1>ğŸŒ² Smooth Sort è¦–è¦ºåŒ– - Leonardo å †æ£®æ—</h1>
    <p class="subtitle">X-Ray æ¼”ç®—æ³•æª¢è¦–ï¼šå¾åº•éƒ¨é™£åˆ—åˆ°é ‚éƒ¨å †æ£®æ—çš„å®Œæ•´è¦–åœ–</p>
    
    <div id="controls">
        <input type="text" id="number-input" placeholder="è¼¸å…¥æ•¸å­—ï¼Œç”¨ç©ºæ ¼åˆ†éš” (ä¾‹å¦‚: 7 2 8 1 4 9)">
        <button id="start-button">é–‹å§‹æ’åº</button>
        <button id="auto-play-button">è‡ªå‹•æ’­æ”¾</button>
        <div class="slider-container">
            <label for="speed-slider">é€Ÿåº¦:</label>
            <input type="range" id="speed-slider" min="50" max="1500" value="600">
            <span id="speed-value">600ms</span>
        </div>
    </div>

    <div class="main-container">
        <div id="canvas-section">
            <canvas id="sort-canvas"></canvas>
        </div>
        <div id="info-panel">
            <div class="panel-section">
                <div class="section-title">âš™ï¸ ç•¶å‰ç‹€æ…‹</div>
                <div class="state-description" id="state-text">æº–å‚™å°±ç·’</div>
            </div>
            <div class="panel-section">
                <div class="section-title">ğŸ”ï¸ å †æ£®æ—çµæ§‹</div>
                <div id="heap-structure"></div>
            </div>
            <div class="panel-section">
                <div class="section-title">ğŸ“Š çµ±è¨ˆ</div>
                <div class="heap-info" id="stats">å·²è®€å–: 0 / æ­¥é©Ÿ: 0</div>
            </div>
            <div class="panel-section">
                <div class="section-title">ğŸ¨ åœ–ä¾‹</div>
                <div class="legend">
                    <div class="legend-item blue"><div class="legend-color"></div> <span>åˆä½µä¸­çš„å­å †</span></div>
                    <div class="legend-item gold"><div class="legend-color"></div> <span>æ–°å¢çš„æ ¹ç¯€é»</span></div>
                    <div class="legend-item red"><div class="legend-color"></div> <span>æ ¹ç¯€é»æ¯”è¼ƒ</span></div>
                    <div class="legend-item green"><div class="legend-color"></div> <span>å·²æ’åº</span></div>
                </div>
            </div>
            <div class="panel-section">
                <div class="step-counter" id="step-counter">æ­¥é©Ÿ: 0/0</div>
                <div class="button-group">
                    <button id="prev-step">â¬…ï¸ ä¸Šä¸€æ­¥</button>
                    <button id="next-step">ä¸‹ä¸€æ­¥ â¡ï¸</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ Leonardo æ•¸åˆ—å¸¸æ•¸ ============
        const LEONARDO = [1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049, 242785, 392835, 635621, 1028457, 1664079, 2692537, 4356617, 7049155, 11405773, 18454929, 29860703, 48315633, 78176337, 126491971, 204668309, 331160281, 535828591, 866988873];

        // ============ UI å…ƒç´  ============
        const canvas = document.getElementById('sort-canvas');
        const ctx = canvas.getContext('2d');
        const numberInput = document.getElementById('number-input');
        const startButton = document.getElementById('start-button');
        const autoPlayButton = document.getElementById('auto-play-button');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        const stateText = document.getElementById('state-text');
        const heapStructure = document.getElementById('heap-structure');
        const stats = document.getElementById('stats');
        const stepCounter = document.getElementById('step-counter');
        const prevStepBtn = document.getElementById('prev-step');
        const nextStepBtn = document.getElementById('next-step');

        let animationSpeed = 600;
        let isSorting = false;
        let currentStep = 0;
        let totalSteps = 0;
        let isAutoPlaying = false;
        let animationFrameId = null;

        // ============ è³‡æ–™çµæ§‹ ============
        class SmoothSortVisualizer {
            constructor(array) {
                this.originalArray = [...array];
                this.n = array.length;
                this.steps = [];
                this.elementValues = {};
                
                for (let i = 0; i < array.length; i++) {
                    this.elementValues[i] = array[i];
                }
                
                this.generateSteps();
            }

            cloneHeap(heap) {
                if (!heap) return null;
                return {
                    root: heap.root,
                    size: heap.size,
                    leonardoIndex: heap.leonardoIndex,
                    leftChild: this.cloneHeap(heap.leftChild),
                    rightChild: this.cloneHeap(heap.rightChild)
                };
            }

            generateSteps() {
                this.steps = [];
                const forest = [];
                const sorted = [];
                
                // å»ºæ§‹éšæ®µ (Building Phase)
                this.steps.push({
                    type: 'phase_start',
                    phase: 'BUILDING',
                    message: 'é–‹å§‹å»ºæ§‹ Leonardo å †æ£®æ—...',
                    forest: [],
                    sorted: [],
                    elementValues: {...this.elementValues}
                });

                for (let i = 0; i < this.n; i++) {
                    this.addElementSteps(i, forest, sorted);
                }

                this.steps.push({
                    type: 'phase_end',
                    phase: 'BUILDING',
                    message: 'å †æ£®æ—å»ºæ§‹å®Œæˆã€‚é–‹å§‹æ’åºéšæ®µ...',
                    forest: forest.map(h => this.cloneHeap(h)),
                    sorted: [...sorted],
                    elementValues: {...this.elementValues}
                });

                // æ’åºéšæ®µ (Sorting Phase)
                this.steps.push({
                    type: 'phase_start',
                    phase: 'SORTING',
                    message: 'é–‹å§‹èƒå–æ ¹ç¯€é»é€²è¡Œæ’åº...',
                    forest: forest.map(h => this.cloneHeap(h)),
                    sorted: [...sorted],
                    elementValues: {...this.elementValues}
                });

                while (forest.length > 0) {
                    this.extractMaxSteps(forest, sorted);
                }

                this.steps.push({
                    type: 'phase_end',
                    phase: 'SORTING',
                    message: 'æ’åºå®Œæˆï¼',
                    forest: [],
                    sorted: [...sorted],
                    elementValues: {...this.elementValues}
                });
            }

            addElementSteps(elementIndex, forest, sorted) {
                const value = this.originalArray[elementIndex];
                
                this.steps.push({
                    type: 'read_element',
                    elementIndex,
                    value,
                    message: `è®€å–æ–°å…ƒç´ : ç´¢å¼•[${elementIndex}] = ${value}`,
                    forest: forest.map(h => this.cloneHeap(h)),
                    sorted: [...sorted],
                    elementValues: {...this.elementValues}
                });

                // æ¯æ¬¡æ·»åŠ æ–°å…ƒç´ æ™‚ï¼Œå…ˆå‰µå»ºä¸€å€‹æ–°å †
                // åœ¨ Smooth Sort ä¸­ï¼Œæ–°å †çš„ Leonardo ç´šåˆ¥å–æ±ºæ–¼ç•¶å‰æ£®æ—çš„ç‹€æ…‹
                let newLeonardoIdx;
                
                if (forest.length === 0) {
                    // ç¬¬ä¸€å€‹å…ƒç´ ï¼šå‰µå»º L(1)
                    newLeonardoIdx = 1;
                } else {
                    const lastHeapIdx = forest[forest.length - 1].leonardoIndex;
                    
                    // å¦‚æœæœ€å¾Œä¸€å€‹å †æ˜¯ L(0)ï¼Œæ–°å †æ‡‰è©²æ˜¯ L(1)ï¼Œç„¶å¾Œå˜—è©¦å’Œå®ƒåˆä½µæˆ L(2)
                    // å¦å‰‡ï¼Œæ–°å †æ‡‰è©²æ˜¯ L(0)
                    if (lastHeapIdx === 0) {
                        newLeonardoIdx = 1;
                    } else {
                        newLeonardoIdx = 0;
                    }
                }

                const newHeapSize = LEONARDO[newLeonardoIdx];
                const newHeap = {
                    root: elementIndex,
                    size: newHeapSize,
                    leonardoIndex: newLeonardoIdx,
                    leftChild: null,
                    rightChild: null
                };

                // å˜—è©¦åˆä½µ: å¦‚æœæœ€å¾Œå…©å€‹å †çš„å¤§å°åˆ†åˆ¥æ˜¯ L(k+1) å’Œ L(k)ï¼ŒåŠ ä¸Šæ–°å †ï¼Œå°±åˆä½µ
                if (forest.length >= 2) {
                    const lastHeap = forest[forest.length - 1];
                    const secondLastHeap = forest[forest.length - 2];
                    
                    const lastIdx = lastHeap.leonardoIndex;
                    const secondLastIdx = secondLastHeap.leonardoIndex;

                    // åˆä½µæ¢ä»¶ï¼šsecondLastIdx === lastIdx + 1
                    if (secondLastIdx === lastIdx + 1) {
                        const mergedIdx = secondLastIdx + 1;
                        const mergedSize = LEONARDO[mergedIdx];

                        this.steps.push({
                            type: 'merge_heaps',
                            message: `åˆä½µ: L(${secondLastIdx}) [æ ¹: ${this.originalArray[secondLastHeap.root]}] + L(${lastIdx}) [æ ¹: ${this.originalArray[lastHeap.root]}] + æ–°å…ƒç´  ${value} = L(${mergedIdx}) [æ–°æ ¹: ${value}]`,
                            forest: forest.map(h => this.cloneHeap(h)),
                            sorted: [...sorted],
                            elementValues: {...this.elementValues}
                        });

                        const mergedHeap = {
                            root: elementIndex,
                            size: mergedSize,
                            leonardoIndex: mergedIdx,
                            leftChild: this.cloneHeap(secondLastHeap),
                            rightChild: this.cloneHeap(lastHeap)
                        };

                        forest.pop();
                        forest.pop();
                        forest.push(mergedHeap);
                    } else {
                        forest.push(newHeap);
                    }
                } else {
                    // å †æ•¸ < 2ï¼Œç›´æ¥æ·»åŠ 
                    forest.push(newHeap);
                }

                // è¨˜éŒ„æ·»åŠ å¾Œçš„ç‹€æ…‹
                this.steps.push({
                    type: 'element_added',
                    elementIndex,
                    message: `å½“å‰å †æ£®æ—: [${forest.map(h => `L(${h.leonardoIndex})`).join(', ')}]`,
                    forest: forest.map(h => this.cloneHeap(h)),
                    sorted: [...sorted],
                    elementValues: {...this.elementValues}
                });

                // åŸ·è¡Œæ ¹ç¯€é»å¹³è¡¡
                this.rebalanceRootsSteps(forest, sorted);
            }

            rebalanceRootsSteps(forest, sorted) {
                if (forest.length < 2) return;

                for (let i = forest.length - 2; i >= 0; i--) {
                    const leftHeap = forest[i];
                    const rightHeap = forest[i + 1];
                    
                    const leftRoot = this.elementValues[leftHeap.root];
                    const rightRoot = this.elementValues[rightHeap.root];

                    if (leftRoot > rightRoot) {
                        this.steps.push({
                            type: 'compare_roots',
                            message: `æ ¹ç¯€é»æ¯”è¼ƒ: å·¦æ ¹ ${leftRoot} > å³æ ¹ ${rightRoot}ï¼Ÿæ˜¯ã€‚äº¤æ›ä¸­...`,
                            forest: forest.map(h => this.cloneHeap(h)),
                            sorted: [...sorted],
                            elementValues: {...this.elementValues},
                            leftHeapIndex: i,
                            rightHeapIndex: i + 1
                        });

                        // äº¤æ›æ ¹ç¯€é»
                        [leftHeap.root, rightHeap.root] = [rightHeap.root, leftHeap.root];

                        // ç¯©é¸ (Sift Down)
                        this.steps.push({
                            type: 'sift_down',
                            message: `åœ¨å·¦å †åŸ·è¡Œç¯©é¸ä»¥ç¶­æŒå †ç‰¹æ€§...`,
                            forest: forest.map(h => this.cloneHeap(h)),
                            sorted: [...sorted],
                            elementValues: {...this.elementValues},
                            heapIndex: i
                        });
                    }
                }
            }

            extractMaxSteps(forest, sorted) {
                if (forest.length === 0) return;

                const maxHeap = forest[forest.length - 1];
                const maxValue = this.elementValues[maxHeap.root];

                this.steps.push({
                    type: 'extract_max',
                    message: `èƒå–æœ€å¤§å…ƒç´ : ${maxValue}`,
                    forest: forest.map(h => this.cloneHeap(h)),
                    sorted: [...sorted],
                    elementValues: {...this.elementValues},
                    extractedElement: maxHeap.root
                });

                sorted.push(maxHeap.root);
                forest.pop();

                // å¦‚æœæå–çš„å †å¤§å° > 1ï¼Œå‰‡åˆ†è£‚ç‚ºå…©å€‹è¼ƒå°çš„å †
                if (maxHeap.size > 1) {
                    const leonardoIdx = LEONARDO.indexOf(maxHeap.size);
                    if (leonardoIdx > 0) {
                        this.steps.push({
                            type: 'split_heap',
                            message: `åˆ†è£‚ L(${leonardoIdx}) ç‚º L(${leonardoIdx - 2}) å’Œ L(${leonardoIdx - 1})`,
                            forest: forest.map(h => this.cloneHeap(h)),
                            sorted: [...sorted],
                            elementValues: {...this.elementValues}
                        });

                        if (maxHeap.leftChild) {
                            forest.push(this.cloneHeap(maxHeap.leftChild));
                        }
                        if (maxHeap.rightChild) {
                            forest.push(this.cloneHeap(maxHeap.rightChild));
                        }
                    }
                }

                // é‡æ–°å¹³è¡¡
                this.rebalanceRootsSteps(forest, sorted);
            }
        }

        // ============ è¦–è¦ºåŒ–å’Œç¹ªåœ– ============
        function setupCanvas() {
            const container = document.getElementById('canvas-section');
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = 600 * dpr;
            
            canvas.style.width = `${rect.width - 30}px`;
            canvas.style.height = '600px';
            
            ctx.scale(dpr, dpr);
        }

        function drawVisualization(visualizer, stepIndex) {
            const step = visualizer.steps[stepIndex];
            if (!step) return;

            const canvasW = canvas.width / (window.devicePixelRatio || 1);
            const canvasH = canvas.height / (window.devicePixelRatio || 1);
            
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, canvasW, canvasH);

            // ç¹ªè£½é™£åˆ—å±¤ (åº•éƒ¨)
            drawArrayLayer(step, visualizer, canvasW, canvasH);

            // ç¹ªè£½å †æ£®æ—å±¤ (é ‚éƒ¨)
            drawForestLayer(step, visualizer, canvasW, canvasH);
        }

        function drawArrayLayer(step, visualizer, canvasW, canvasH) {
            const arrayY = canvasH - 80;
            const boxWidth = 40;
            const boxHeight = 30;
            const startX = (canvasW - visualizer.n * boxWidth) / 2;

            const forest = step.forest || [];
            const sorted = step.sorted || [];

            ctx.fillStyle = '#3c3c3c';
            ctx.strokeStyle = '#4ec9b0';
            ctx.lineWidth = 2;
            ctx.font = '12px monospace';
            ctx.fillStyle = '#d4d4d4';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < visualizer.n; i++) {
                const x = startX + i * boxWidth;
                const y = arrayY;
                const value = visualizer.elementValues[i];

                // ç¢ºå®šé¡è‰²
                let isInForest = false;
                for (const heap of forest) {
                    if (isElementInHeap(i, heap)) {
                        isInForest = true;
                        break;
                    }
                }

                let isSorted = sorted.includes(i);

                if (isSorted) {
                    ctx.fillStyle = '#6a9955';
                } else if (isInForest) {
                    ctx.fillStyle = '#569cd6';
                } else {
                    ctx.fillStyle = '#3c3c3c';
                }

                ctx.fillRect(x, y, boxWidth, boxHeight);
                ctx.strokeStyle = '#4ec9b0';
                ctx.strokeRect(x, y, boxWidth, boxHeight);

                ctx.fillStyle = '#d4d4d4';
                ctx.font = 'bold 12px monospace';
                ctx.fillText(value, x + boxWidth / 2, y + boxHeight / 2);
                
                ctx.fillStyle = '#858585';
                ctx.font = '10px monospace';
                ctx.fillText(`[${i}]`, x + boxWidth / 2, y + boxHeight + 15);
            }
        }

        function isElementInHeap(elementIndex, heap) {
            if (!heap) return false;
            if (heap.root === elementIndex) return true;
            if (heap.leftChild && isElementInHeap(elementIndex, heap.leftChild)) return true;
            if (heap.rightChild && isElementInHeap(elementIndex, heap.rightChild)) return true;
            return false;
        }

        function drawForestLayer(step, visualizer, canvasW, canvasH) {
            const forest = step.forest || [];
            const forestY = 100;
            const heapSpacing = canvasW / (Math.max(forest.length, 1) + 1);

            for (let i = 0; i < forest.length; i++) {
                const heap = forest[i];
                const heapCenterX = heapSpacing * (i + 1);
                
                // ç•«å †
                drawHeapTree(heap, heapCenterX, forestY, visualizer, canvasW, canvasH);
            }
        }

        function drawHeapTree(heap, centerX, topY, visualizer, canvasW, canvasH) {
            const getTreeWidth = (h, depth = 0) => {
                if (!h || depth > 10) return 40;
                const leftWidth = h.leftChild ? getTreeWidth(h.leftChild, depth + 1) : 0;
                const rightWidth = h.rightChild ? getTreeWidth(h.rightChild, depth + 1) : 0;
                return Math.max(80, leftWidth + rightWidth + 40);
            };

            const width = getTreeWidth(heap);
            drawNode(heap, centerX, topY, width / 2, visualizer, canvasW, canvasH);
        }

        function drawNode(heap, x, y, maxWidth, visualizer, canvasW, canvasH, depth = 0) {
            if (!heap || depth > 15) return;

            const radius = 20;
            const value = visualizer.elementValues[heap.root];

            // ç¹ªè£½é‚Š
            if (heap.leftChild) {
                const leftX = x - maxWidth / 2;
                const leftY = y + 70;
                ctx.strokeStyle = 'rgba(212, 212, 212, 0.4)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(leftX, leftY);
                ctx.stroke();
                drawNode(heap.leftChild, leftX, leftY, maxWidth / 2.5, visualizer, canvasW, canvasH, depth + 1);
            }

            if (heap.rightChild) {
                const rightX = x + maxWidth / 2;
                const rightY = y + 70;
                ctx.strokeStyle = 'rgba(212, 212, 212, 0.4)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(rightX, rightY);
                ctx.stroke();
                drawNode(heap.rightChild, rightX, rightY, maxWidth / 2.5, visualizer, canvasW, canvasH, depth + 1);
            }

            // ç¹ªè£½ç¯€é»åœ“åœˆ
            ctx.fillStyle = '#569cd6';
            ctx.strokeStyle = '#4ec9b0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // ç¹ªè£½æ•¸å€¼
            ctx.fillStyle = '#1e1e1e';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(value, x, y);

            // ç¹ªè£½å¤§å°æ¨™è¨˜
            ctx.fillStyle = '#858585';
            ctx.font = '10px monospace';
            const leonardoIdx = heap.leonardoIndex || 0;
            ctx.fillText(`L(${leonardoIdx})`, x, y + 35);
        }

        // ============ ç‹€æ…‹æ›´æ–° ============
        function updatePanelInfo(visualizer, stepData) {
            // æ›´æ–°ç‹€æ…‹èªªæ˜
            stateText.textContent = stepData.message || 'åŸ·è¡Œä¸­...';

            // æ›´æ–°å †æ£®æ—çµæ§‹
            const forest = stepData.forest || [];
            let heapHTML = '';
            for (let i = 0; i < forest.length; i++) {
                const heap = forest[i];
                const root = visualizer.elementValues[heap.root];
                heapHTML += `<div class="heap-info">å † #${i + 1}: L(${heap.leonardoIndex}) [å¤§å°: ${heap.size}] æ ¹: ${root}</div>`;
            }
            if (heapHTML === '') heapHTML = '<div class="heap-info">æ£®æ—ç‚ºç©º</div>';
            heapStructure.innerHTML = heapHTML;

            // æ›´æ–°çµ±è¨ˆè³‡è¨Š
            const sorted = stepData.sorted || [];
            const processed = sorted.length;
            const total = visualizer.n;
            stats.innerHTML = `å·²æ’åº: ${processed} / ${total} | ç•¶å‰æ­¥é©Ÿ: ${currentStep + 1}`;

            // æ›´æ–°æ­¥é©Ÿè¨ˆæ•¸å™¨
            stepCounter.textContent = `æ­¥é©Ÿ: ${currentStep + 1} / ${totalSteps}`;
        }

        // ============ ä¸»æ§åˆ¶é‚è¼¯ ============
        function startSort() {
            if (isSorting) return;

            const inputText = numberInput.value.trim();
            if (!inputText) {
                alert('è«‹è¼¸å…¥æ•¸å­—ï¼');
                return;
            }

            const numbers = inputText.split(/\s+/).map(Number).filter(n => !isNaN(n));
            if (numbers.length === 0) {
                alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å­—ï¼');
                return;
            }

            isSorting = true;
            isAutoPlaying = false;
            currentStep = 0;

            const visualizer = new SmoothSortVisualizer(numbers);
            totalSteps = visualizer.steps.length;

            setupCanvas();
            updatePanelInfo(visualizer, visualizer.steps[0]);
            drawVisualization(visualizer, 0);

            // å•Ÿç”¨ä¸‹ä¸€æ­¥æŒ‰éˆ•
            prevStepBtn.disabled = currentStep === 0;
            nextStepBtn.disabled = false;

            // å­˜å„²ä»¥ä¾›ä½¿ç”¨
            window.currentVisualizer = visualizer;
        }

        function goToStep(stepIndex) {
            if (!window.currentVisualizer) return;
            if (stepIndex < 0 || stepIndex >= totalSteps) return;

            currentStep = stepIndex;
            const step = window.currentVisualizer.steps[currentStep];
            
            updatePanelInfo(window.currentVisualizer, step);
            drawVisualization(window.currentVisualizer, currentStep);

            prevStepBtn.disabled = currentStep === 0;
            nextStepBtn.disabled = currentStep === totalSteps - 1;
        }

        function nextStep() {
            if (currentStep < totalSteps - 1) {
                goToStep(currentStep + 1);
            }
        }

        function prevStep() {
            if (currentStep > 0) {
                goToStep(currentStep - 1);
            }
        }

        async function autoPlay() {
            if (isAutoPlaying) {
                isAutoPlaying = false;
                autoPlayButton.textContent = 'è‡ªå‹•æ’­æ”¾';
                return;
            }

            isAutoPlaying = true;
            autoPlayButton.textContent = 'æš«åœ';
            autoPlayButton.disabled = true;
            startButton.disabled = true;
            prevStepBtn.disabled = true;
            nextStepBtn.disabled = true;

            while (currentStep < totalSteps - 1 && isAutoPlaying) {
                nextStep();
                await new Promise(resolve => setTimeout(resolve, animationSpeed));
            }

            isAutoPlaying = false;
            autoPlayButton.textContent = 'è‡ªå‹•æ’­æ”¾';
            autoPlayButton.disabled = false;
            startButton.disabled = false;
            prevStepBtn.disabled = currentStep === 0;
            nextStepBtn.disabled = currentStep === totalSteps - 1;
        }

        // ============ äº‹ä»¶ç›£è½ ============
        startButton.addEventListener('click', startSort);
        nextStepBtn.addEventListener('click', nextStep);
        prevStepBtn.addEventListener('click', prevStep);
        autoPlayButton.addEventListener('click', autoPlay);

        speedSlider.addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value, 10);
            speedValue.textContent = `${animationSpeed}ms`;
        });

        window.addEventListener('resize', () => {
            if (window.currentVisualizer && !isSorting) {
                setupCanvas();
                drawVisualization(window.currentVisualizer, currentStep);
            }
        });

        // åˆå§‹åŒ–
        numberInput.value = "7 2 8 1 4 9";
        setupCanvas();
        prevStepBtn.disabled = true;
        nextStepBtn.disabled = true;
    </script>
</body>
</html>
