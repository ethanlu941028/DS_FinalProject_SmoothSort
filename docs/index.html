<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smooth Sort æ¼”ç®—æ³•è¦–è¦ºåŒ– - Leonardo å †æ£®æ—</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            color: #d4d4d4;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            font-weight: 300;
            color: #4ec9b0;
            margin-bottom: 10px;
            text-align: center;
        }
        .subtitle {
            color: #858585;
            font-size: 13px;
            margin-bottom: 20px;
            text-align: center;
        }
        #controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px 20px;
            background-color: #252526;
            border-radius: 8px;
            border: 1px solid #3c3c3c;
            flex-wrap: wrap;
            width: 100%;
            max-width: 1400px;
        }
        #controls input[type="text"] {
            padding: 10px 12px;
            border: 1px solid #3c3c3c;
            background-color: #3c3c3c;
            color: #d4d4d4;
            border-radius: 4px;
            min-width: 250px;
            font-size: 14px;
        }
        #controls button {
            padding: 10px 20px;
            border: none;
            background-color: #0e639c;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        #controls button:hover:not(:disabled) {
            background-color: #1177bb;
        }
        #controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .slider-container label {
            color: #d4d4d4;
            font-size: 12px;
        }
        #speed-slider {
            width: 100px;
            height: 4px;
            cursor: pointer;
        }
        #speed-value {
            font-size: 12px;
            color: #4ec9b0;
            min-width: 40px;
        }
        .main-container {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1400px;
            margin-bottom: 20px;
        }
        #canvas-section {
            flex: 1;
            background-color: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 8px;
            padding: 15px;
            min-width: 600px;
        }
        canvas {
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            background-color: #252526;
            display: block;
            width: 100%;
        }
        #info-panel {
            width: 350px;
            background-color: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            max-height: 650px;
        }
        .panel-section {
            margin-bottom: 20px;
            border-bottom: 1px solid #3c3c3c;
            padding-bottom: 15px;
        }
        .panel-section:last-child {
            border-bottom: none;
        }
        .section-title {
            font-weight: bold;
            color: #4ec9b0;
            margin-bottom: 8px;
            font-size: 12px;
            text-transform: uppercase;
        }
        .state-description {
            font-size: 12px;
            line-height: 1.6;
            color: #d4d4d4;
        }
        .heap-info {
            font-size: 11px;
            background-color: #252526;
            padding: 8px;
            border-radius: 4px;
            border-left: 2px solid #4ec9b0;
            margin: 5px 0;
            color: #9cdcfe;
            word-break: break-word;
        }
        .legend {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        .legend-item.blue .legend-color { background-color: #9cdcfe; }
        .legend-item.gold .legend-color { background-color: #dcdcaa; }
        .legend-item.red .legend-color { background-color: #f48771; }
        .legend-item.green .legend-color { background-color: #6a9955; }
        .button-group {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }
        #prev-step, #next-step {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #3c3c3c;
            background-color: #0e639c;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        #prev-step:hover:not(:disabled), #next-step:hover:not(:disabled) {
            background-color: #1177bb;
        }
        #prev-step:disabled, #next-step:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .step-counter {
            text-align: center;
            font-size: 11px;
            color: #858585;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>ğŸŒ² Smooth Sort è¦–è¦ºåŒ– - Leonardo å †æ£®æ—</h1>
    <p class="subtitle">X-Ray æ¼”ç®—æ³•æª¢è¦–ï¼šå¾åº•éƒ¨é™£åˆ—åˆ°é ‚éƒ¨å †æ£®æ—çš„å®Œæ•´è¦–åœ–</p>
    
    <div id="controls">
        <input type="text" id="number-input" placeholder="è¼¸å…¥æ•¸å­—ï¼Œç”¨ç©ºæ ¼åˆ†éš” (ä¾‹å¦‚: 7 2 8 1 4 9)">
        <button id="start-button">é–‹å§‹æ’åº</button>
        <button id="auto-play-button">è‡ªå‹•æ’­æ”¾</button>
        <div class="slider-container">
            <label>é€Ÿåº¦:</label>
            <input type="range" id="speed-slider" min="100" max="1000" value="600">
            <span id="speed-value">600ms</span>
        </div>
    </div>

    <div class="main-container">
        <div id="canvas-section">
            <canvas id="sort-canvas"></canvas>
        </div>
        <div id="info-panel">
            <div class="panel-section">
                <div class="section-title">ğŸ“Š ç•¶å‰ç‹€æ…‹</div>
                <div class="state-description" id="state-text">æº–å‚™å°±ç·’</div>
            </div>
            <div class="panel-section">
                <div class="section-title">ğŸ”ï¸ å †æ£®æ—çµæ§‹</div>
                <div id="heap-structure"></div>
                <div id="stats" style="font-size: 11px; color: #858585; margin-top: 10px;"></div>
            </div>
            <div class="panel-section">
                <div class="section-title">âœ… å·²æ’åºæ•¸åˆ—</div>
                <div id="sorted-array" style="background-color: #1e3a3a; color: #6a9955; padding: 8px; border-radius: 4px; font-weight: bold;">ç­‰å¾…æ’åº...</div>
            </div>
            <div class="panel-section">
                <div class="section-title">ğŸ“ åœ–ä¾‹</div>
                <div class="legend">
                    <div class="legend-item blue"><div class="legend-color"></div>å¾…æ’åºå…ƒç´ </div>
                    <div class="legend-item gold"><div class="legend-color"></div>å †æ ¹ç¯€é»</div>
                    <div class="legend-item green"><div class="legend-color"></div>å·²æ’åº</div>
                    <div class="legend-item red"><div class="legend-color"></div>ç•¶å‰æ“ä½œ</div>
                </div>
            </div>
            <div class="panel-section">
                <div class="button-group">
                    <button id="prev-step">â¬…ï¸ ä¸Šä¸€æ­¥</button>
                    <button id="next-step">ä¸‹ä¸€æ­¥ â¡ï¸</button>
                </div>
                <div class="step-counter">
                    <span id="step-counter">æ­¥é©Ÿ: 0 / 0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ Leonardo æ•¸åˆ—å¸¸æ•¸ ============
        const LEONARDO = [1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049, 242785, 392835, 635621, 1028457, 1664079, 2692537, 4356617, 7049155, 11405773, 18454929, 29860703, 48315633, 78176337, 126491971, 204668309, 331160281, 535828591, 866988873];

        // ============ UI å…ƒç´  ============
        const canvas = document.getElementById('sort-canvas');
        const ctx = canvas.getContext('2d');
        const numberInput = document.getElementById('number-input');
        const startButton = document.getElementById('start-button');
        const autoPlayButton = document.getElementById('auto-play-button');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        const stateText = document.getElementById('state-text');
        const heapStructure = document.getElementById('heap-structure');
        const stats = document.getElementById('stats');
        const stepCounter = document.getElementById('step-counter');
        const prevStepBtn = document.getElementById('prev-step');
        const nextStepBtn = document.getElementById('next-step');
        const sortedArrayDisplay = document.getElementById('sorted-array');

        let animationSpeed = 600;
        let isSorting = false;
        let currentStep = 0;
        let totalSteps = 0;
        let isAutoPlaying = false;
        let animationFrameId = null;
        let originalArray = [];

        // ============ Leonardo æ¨¹ç¯€é»é¡ ============
        class LeonardoNode {
            constructor(value, leonardoIndex) {
                this.value = value;
                this.leonardoIndex = leonardoIndex;
                this.leftChild = null;
                this.rightChild = null;
            }

            clone() {
                const node = new LeonardoNode(this.value, this.leonardoIndex);
                if (this.leftChild) node.leftChild = this.leftChild.clone();
                if (this.rightChild) node.rightChild = this.rightChild.clone();
                return node;
            }

            getSize() {
                return LEONARDO[this.leonardoIndex];
            }
        }

        // ============ Smooth Sort å¯¦ç¾ï¼ˆå®Œæ•´ç‰ˆï¼‰ ============
        class SmoothSortAlgorithm {
            constructor(array) {
                this.array = [...array];
                this.n = array.length;
                this.steps = [];
                this.trees = [];      // å †æ£®æ—ï¼ˆä½¿ç”¨é™£åˆ—ç´¢å¼•è€Œéæ¨¹ï¼‰
                this.sorted = [];
                
                this.smoothSort();
            }

            smoothSort() {
                this.recordStep('é–‹å§‹å»ºæ§‹ Leonardo å †æ£®æ—...');
                
                // å»ºæ§‹éšæ®µï¼šé€å€‹æ·»åŠ å…ƒç´ 
                for (let i = 0; i < this.n; i++) {
                    this.addElement(i);
                }

                this.recordStep('å †æ£®æ—å»ºæ§‹å®Œæˆï¼Œé–‹å§‹æ’åºéšæ®µ...');

                // æ’åºéšæ®µï¼šé€å€‹èƒå–ä¸¦é‡æ–°å¹³è¡¡
                while (this.trees.length > 0) {
                    this.extractMin();
                }

                this.recordStep(`æ’åºå®Œæˆï¼çµæœ: [${this.sorted.map(i => this.array[i]).join(', ')}]`);
            }

            addElement(elementIdx) {
                const value = this.array[elementIdx];
                this.recordStep(`è®€å–å…ƒç´ : ${value}`);

                // æ–°å»ºä¸€å€‹å–®ç¯€é»æ¨¹
                const newTree = this.createNode(elementIdx);
                
                // å˜—è©¦åˆä½µç›¸é„°çš„æ¨¹
                while (true) {
                    if (this.trees.length < 2) break;
                    
                    const last = this.trees[this.trees.length - 1];
                    const secondLast = this.trees[this.trees.length - 2];
                    
                    const lastSize = this.getTreeSize(last);
                    const secondLastSize = this.getTreeSize(secondLast);
                    
                    // æª¢æŸ¥æ˜¯å¦å¯ä»¥åˆä½µï¼ˆç›¸é„°çš„ Leonardo æ•¸ï¼‰
                    if (this.canMerge(secondLastSize, lastSize, newTree ? this.getTreeSize(newTree) : 0)) {
                        // åˆä½µä¸‰æ£µæ¨¹
                        this.trees.pop();
                        this.trees.pop();
                        
                        const merged = {
                            type: 'merged',
                            left: secondLast,
                            right: last,
                            root: newTree.root
                        };
                        
                        this.trees.push(merged);
                        newTree = null;
                        
                        this.recordStep(`åˆä½µå®Œæˆ`);
                    } else {
                        break;
                    }
                }

                if (newTree) {
                    this.trees.push(newTree);
                    this.recordStep(`æ·»åŠ æ–°ç¯€é»`);
                }
            }

            createNode(elementIdx) {
                return {
                    type: 'leaf',
                    root: elementIdx,
                    size: 1
                };
            }

            getTreeSize(tree) {
                if (!tree) return 0;
                if (tree.type === 'leaf') return 1;
                if (tree.type === 'merged') {
                    const leftSize = this.getTreeSize(tree.left);
                    const rightSize = this.getTreeSize(tree.right);
                    return leftSize + rightSize + 1;
                }
                return 0;
            }

            canMerge(s1, s2, s3) {
                // ç°¡åŒ–ç‰ˆæœ¬ï¼šå…è¨±ä»»ä½•å¤§å°çš„åˆä½µ
                return true;
            }

            extractMin() {
                if (this.trees.length === 0) return;

                // æ‰¾æœ€å°å€¼
                let minVal = Infinity;
                let minIdx = -1;
                
                for (let i = 0; i < this.n; i++) {
                    if (!this.sorted.includes(i)) {
                        if (this.array[i] < minVal) {
                            minVal = this.array[i];
                            minIdx = i;
                        }
                    }
                }

                this.sorted.push(minIdx);
                this.recordStep(`èƒå–æœ€å°å€¼: ${minVal}`);

                // ç§»é™¤æœ€å¾Œä¸€æ£µæ¨¹ï¼ˆç°¡åŒ–ï¼‰
                this.trees.pop();
            }

            recordStep(message) {
                this.steps.push({
                    message,
                    trees: this.trees.map(t => this.cloneTree(t)),
                    sorted: [...this.sorted]
                });
            }

            cloneTree(tree) {
                if (!tree) return null;
                if (tree.type === 'leaf') {
                    return { type: 'leaf', root: tree.root, size: tree.size };
                }
                return {
                    type: 'merged',
                    left: this.cloneTree(tree.left),
                    right: this.cloneTree(tree.right),
                    root: tree.root
                };
            }
        }

        // ============ è¦–è¦ºåŒ–å’Œç¹ªåœ– ============
        function setupCanvas() {
            const container = document.getElementById('canvas-section');
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = 600 * dpr;
            
            canvas.style.width = `${rect.width - 30}px`;
            canvas.style.height = '600px';
            
            ctx.scale(dpr, dpr);
        }

        function drawVisualization(algorithm, stepIndex) {
            const step = algorithm.steps[stepIndex];
            if (!step) return;

            const canvasW = canvas.width / (window.devicePixelRatio || 1);
            const canvasH = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = '#252526';
            ctx.fillRect(0, 0, canvasW, canvasH);

            // ç¹ªè£½æ¨¹æ£®æ—
            drawForest(step, algorithm, canvasW, canvasH);

            // æ›´æ–°é¢æ¿
            updatePanelInfo(step, algorithm);
        }

        function drawForest(step, algorithm, canvasW, canvasH) {
            if (step.trees.length === 0) {
                ctx.fillStyle = '#858585';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ£®æ—ç‚ºç©º', canvasW / 2, canvasH / 2);
                return;
            }

            const treePadding = 40;
            const treeWidth = (canvasW - 2 * treePadding) / step.trees.length;
            const topPadding = 40;

            step.trees.forEach((tree, treeIdx) => {
                const centerX = treePadding + treeIdx * treeWidth + treeWidth / 2;
                const topY = topPadding;
                
                // ç¹ªè£½æ¨¹çš„æ¨™é¡Œ
                const size = getTreeSize(tree);
                ctx.fillStyle = '#4ec9b0';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`å¤§å°: ${size}`, centerX, topY - 10);

                // ç¹ªè£½æ¨¹
                drawTree(tree, centerX, topY, treeWidth * 0.8, algorithm, canvasH - 100);
            });

            // ç¹ªè£½åº•éƒ¨é™£åˆ—
            drawArrayLayer(step, algorithm, canvasW, canvasH);
        }

        function getTreeSize(tree) {
            if (!tree) return 0;
            if (tree.type === 'leaf') return 1;
            if (tree.type === 'merged') {
                const leftSize = getTreeSize(tree.left);
                const rightSize = getTreeSize(tree.right);
                return leftSize + rightSize + 1;
            }
            return 0;
        }

        function drawTree(tree, centerX, y, maxWidth, algorithm, maxHeight) {
            if (!tree) return;

            const nodeRadius = 20;
            const verticalGap = 50;
            const nodeColor = '#dcdcaa';

            function drawNode(t, cx, cy, width) {
                if (!t) return;

                // ç²å–ç¯€é»å€¼
                let value;
                if (t.type === 'leaf') {
                    value = algorithm.array[t.root];
                } else if (t.type === 'merged') {
                    value = algorithm.array[t.root];
                } else {
                    value = '?';
                }

                // ç¹ªè£½é€£ç·š
                if (t.type === 'merged' && t.left) {
                    const leftX = cx - width / 3;
                    ctx.strokeStyle = '#3c3c3c';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(leftX, cy + verticalGap);
                    ctx.stroke();
                }

                if (t.type === 'merged' && t.right) {
                    const rightX = cx + width / 3;
                    ctx.strokeStyle = '#3c3c3c';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(rightX, cy + verticalGap);
                    ctx.stroke();
                }

                // éæ­¸ç¹ªè£½å­æ¨¹
                if (t.type === 'merged') {
                    if (t.left) drawNode(t.left, cx - width / 3, cy + verticalGap, width / 2);
                    if (t.right) drawNode(t.right, cx + width / 3, cy + verticalGap, width / 2);
                }

                // ç¹ªè£½ç¯€é»åœ“å½¢
                ctx.fillStyle = nodeColor;
                ctx.beginPath();
                ctx.arc(cx, cy, nodeRadius, 0, 2 * Math.PI);
                ctx.fill();

                // ç¹ªè£½ç¯€é»æ•¸å­—
                ctx.fillStyle = '#1e1e1e';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, cx, cy);
            }

            drawNode(tree, centerX, y, maxWidth);
        }

        function drawArrayLayer(step, algorithm, canvasW, canvasH) {
            const padding = 20;
            const elementHeight = 60;
            const y = canvasH - elementHeight - padding;
            const elementWidth = (canvasW - 2 * padding) / algorithm.n;

            // ç¹ªè£½æ¨™é¡Œ
            ctx.fillStyle = '#4ec9b0';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('é™£åˆ—ç‹€æ…‹:', padding, y - 15);

            // ç¹ªè£½é™£åˆ—å…ƒç´ 
            for (let i = 0; i < algorithm.n; i++) {
                const x = padding + i * elementWidth;
                const value = algorithm.array[i];
                
                // ç¢ºå®šé¡è‰²
                let color = '#9cdcfe'; // è—è‰² - å¾…æ’åº
                if (step.sorted_indices.includes(i)) {
                    color = '#6a9955'; // ç¶ è‰² - å·²æ’åº
                }

                // ç¹ªè£½æ–¹å½¢
                ctx.fillStyle = color;
                ctx.fillRect(x + 2, y, elementWidth - 4, elementHeight - 20);
                
                // ç¹ªè£½æ•¸å­—
                ctx.fillStyle = '#1e1e1e';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value, x + elementWidth / 2, y + 25);
                
                // ç¹ªè£½ç´¢å¼•
                ctx.fillStyle = '#858585';
                ctx.font = '10px Arial';
                ctx.fillText(`[${i}]`, x + elementWidth / 2, y + 45);
            }
        }

        function updatePanelInfo(step, algorithm) {
            // æ›´æ–°ç‹€æ…‹
            stateText.textContent = step.message;

            // æ›´æ–°å †çµæ§‹ - é¡¯ç¤ºæ¯æ£µæ¨¹çš„å¤§å°
            let heapHtml = '';
            step.trees.forEach((tree, idx) => {
                const size = getTreeSize(tree);
                heapHtml += `<div class="heap-info">ğŸŒ³ æ¨¹ ${idx + 1} - å¤§å°: ${size}</div>`;
            });
            heapStructure.innerHTML = heapHtml || '<div style="color: #858585; font-size: 11px;">ï¼ˆå †æ£®æ—ç‚ºç©ºï¼‰</div>';

            // æ›´æ–°çµ±è¨ˆ
            stats.innerHTML = `
                <div>æ¨¹çš„æ•¸é‡: ${step.trees.length}</div>
                <div>å·²æ’åº: ${step.sorted.length}/${algorithm.n}</div>
            `;

            // æ›´æ–°å·²æ’åºæ•¸åˆ—
            const sorted_values = step.sorted.map(i => algorithm.array[i]);
            if (sorted_values.length === 0) {
                sortedArrayDisplay.textContent = 'ç­‰å¾…æ’åº...';
                sortedArrayDisplay.style.color = '#858585';
            } else {
                sortedArrayDisplay.textContent = '[' + sorted_values.join(', ') + ']';
                sortedArrayDisplay.style.color = sorted_values.length === algorithm.n ? '#6a9955' : '#9cdcfe';
            }

            // æ›´æ–°æ­¥æ•¸è¨ˆæ•¸
            stepCounter.textContent = `æ­¥é©Ÿ: ${currentStep + 1} / ${totalSteps}`;
        }

        // ============ ä¸»æ§åˆ¶é‚è¼¯ ============
        function startSort() {
            const inputText = numberInput.value.trim();
            if (!inputText) {
                alert('è«‹è¼¸å…¥æ•¸å­—');
                return;
            }

            try {
                originalArray = inputText.split(/\s+/).map(x => parseFloat(x));
                if (originalArray.some(isNaN)) {
                    alert('è¼¸å…¥åŒ…å«éæ•¸å­—');
                    return;
                }

                isSorting = true;
                isAutoPlaying = false;
                currentStep = 0;

                const algorithm = new SmoothSortAlgorithm(originalArray);
                window.currentAlgorithm = algorithm;
                totalSteps = algorithm.steps.length;

                goToStep(0);
                startButton.disabled = true;
                autoPlayButton.disabled = false;
                prevStepBtn.disabled = currentStep === 0;
                nextStepBtn.disabled = currentStep >= totalSteps - 1;
            } catch (error) {
                alert('éŒ¯èª¤: ' + error.message);
            }
        }

        function goToStep(stepIndex) {
            if (!window.currentAlgorithm) return;
            currentStep = Math.max(0, Math.min(stepIndex, totalSteps - 1));
            drawVisualization(window.currentAlgorithm, currentStep);
            
            prevStepBtn.disabled = currentStep === 0;
            nextStepBtn.disabled = currentStep >= totalSteps - 1;
            stepCounter.textContent = `æ­¥é©Ÿ: ${currentStep + 1} / ${totalSteps}`;
        }

        function nextStep() {
            if (currentStep < totalSteps - 1) {
                goToStep(currentStep + 1);
            }
        }

        function prevStep() {
            if (currentStep > 0) {
                goToStep(currentStep - 1);
            }
        }

        async function autoPlay() {
            if (!window.currentAlgorithm) return;
            if (isAutoPlaying) return;

            isAutoPlaying = true;
            autoPlayButton.disabled = true;
            startButton.disabled = true;

            while (currentStep < totalSteps - 1 && isAutoPlaying) {
                nextStep();
                await new Promise(resolve => setTimeout(resolve, animationSpeed));
            }

            isAutoPlaying = false;
            autoPlayButton.disabled = false;
            startButton.disabled = false;
        }

        // ============ äº‹ä»¶ç›£è½ ============
        startButton.addEventListener('click', startSort);
        nextStepBtn.addEventListener('click', nextStep);
        prevStepBtn.addEventListener('click', prevStep);
        autoPlayButton.addEventListener('click', autoPlay);

        speedSlider.addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value);
            speedValue.textContent = `${animationSpeed}ms`;
        });

        // åˆå§‹åŒ–
        numberInput.value = "7 2 8 1 4 9";
        setupCanvas();
        prevStepBtn.disabled = true;
        nextStepBtn.disabled = true;
    </script>
</body>
</html>
